#!/usr/bin/env bash
#
# Jacker - Unified Docker Home Server Management Platform
# Single CLI interface for all Jacker operations
#
# Usage: jacker <command> [options]
#

set -euo pipefail

# Script location detection
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export JACKER_ROOT="$SCRIPT_DIR"
export JACKER_DIR="$SCRIPT_DIR"

# Source common functions
# shellcheck source=assets/lib/common.sh
source "$JACKER_ROOT/assets/lib/common.sh"

# Version
readonly VERSION="3.0.0"

# ============================================================================
# Main Commands
# ============================================================================

# Show usage
show_usage() {
    cat << EOF
${BLUE}Jacker - Docker Home Server Management Platform v${VERSION}${NC}

${GREEN}Usage:${NC} jacker <command> [options]
       jacker --interactive    # Launch interactive menu

${YELLOW}Core Commands:${NC}
  init            Initialize Jacker (first-time setup)
  start           Start services
  stop            Stop services
  restart         Restart services
  status          Show service status
  logs            View service logs
  shell           Access service shell

${YELLOW}Management Commands:${NC}
  health          Run health checks
  fix             Fix common issues
  backup          Create backup
  restore         Restore from backup
  update          Update Jacker and services
  clean           Clean up containers and data
  wipe-data       Wipe all data (preserves SSL certs)
  tune            Optimize resource allocation

${YELLOW}Configuration Commands:${NC}
  config          Manage configuration
  secrets         Manage secrets
  security        Security operations
  whitelist       Manage CrowdSec IP/DNS whitelist
  alerts          Manage and test alerts

${YELLOW}Information Commands:${NC}
  info            Show system information
  version         Show version information
  help            Show this help message

${GREEN}Global Options:${NC}
  -i, --interactive  Launch interactive TUI menu
  -h, --help         Show help for specific command
  -v, --verbose      Enable verbose output
  -q, --quiet        Suppress non-critical output
  --dry-run          Show what would be done without making changes
  --version          Show version information

${GREEN}Examples:${NC}
  jacker --interactive            # Interactive menu mode
  jacker init                     # First-time setup
  jacker init --auto              # Automated setup with defaults
  jacker status                   # Show all services status
  jacker logs traefik -f          # Follow Traefik logs
  jacker config show              # Show current configuration
  jacker health --verbose         # Detailed health check

For command help: ${CYAN}jacker <command> --help${NC}
Documentation: ${CYAN}https://github.com/yourusername/jacker${NC}
EOF
}

# ============================================================================
# Command: init (replaces setup)
# ============================================================================
cmd_init() {
    local auto_mode=false
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto)
                auto_mode=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker init [options]

Initialize Jacker with smart setup process.

${YELLOW}Options:${NC}
  --auto          Use automatic setup with defaults
  --force         Force reinstall even if already configured
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker init              # Interactive setup
  jacker init --auto       # Automatic setup with smart defaults
  jacker init --force      # Force reinstallation
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Check if already initialized
    if [[ -f "$JACKER_ROOT/.env" ]] && [[ "$force" != "true" ]]; then
        warning "Jacker is already initialized"
        if confirm_action "Do you want to reconfigure?"; then
            backup_file "$JACKER_ROOT/.env"
        else
            info "Use 'jacker init --force' to force reinstallation"
            return 0
        fi
    fi

    # Source setup library
    # shellcheck source=assets/lib/setup.sh
    source "$JACKER_ROOT/assets/lib/setup.sh"

    # Set JACKER_DIR environment variable for setup.sh
    export JACKER_DIR="$JACKER_ROOT"

    if [[ "$auto_mode" == "true" ]]; then
        setup_jacker "quick"
    else
        setup_jacker "interactive"
    fi
}

# ============================================================================
# Command: start
# ============================================================================
cmd_start() {
    local services=()
    local detach=true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --attach)
                detach=false
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker start [services...] [options]

Start Jacker services.

${YELLOW}Options:${NC}
  --attach        Don't detach (run in foreground)
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker start                # Start all services
  jacker start traefik oauth  # Start specific services
  jacker start --attach       # Start in foreground
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                services+=("$1")
                shift
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    if [[ ${#services[@]} -eq 0 ]]; then
        info "Starting all services..."
        if [[ "$detach" == "true" ]]; then
            execute_or_dry_run "docker compose up -d"
        else
            execute_or_dry_run "docker compose up"
        fi
    else
        # Validate each service
        for service in "${services[@]}"; do
            if ! validate_service_name "$service"; then
                return 1
            fi
        done

        info "Starting services: ${services[*]}"
        if [[ "$detach" == "true" ]]; then
            execute_or_dry_run "docker compose up -d ${services[*]}"
        else
            execute_or_dry_run "docker compose up ${services[*]}"
        fi
    fi

    if [[ "$detach" == "true" ]]; then
        success "Services started"
        info "Run 'jacker status' to check service status"
    fi
}

# ============================================================================
# Command: stop
# ============================================================================
cmd_stop() {
    local services=()
    local remove_volumes=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --volumes|-v)
                remove_volumes=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker stop [services...] [options]

Stop Jacker services.

${YELLOW}Options:${NC}
  --volumes, -v   Also remove volumes
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker stop                 # Stop all services
  jacker stop traefik        # Stop specific service
  jacker stop --volumes      # Stop and remove volumes
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                services+=("$1")
                shift
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    if [[ ${#services[@]} -eq 0 ]]; then
        info "Stopping all services..."
        if [[ "$remove_volumes" == "true" ]]; then
            execute_or_dry_run "docker compose down -v"
        else
            execute_or_dry_run "docker compose down"
        fi
    else
        # Validate each service
        for service in "${services[@]}"; do
            if ! validate_service_name "$service"; then
                return 1
            fi
        done

        info "Stopping services: ${services[*]}"
        execute_or_dry_run "docker compose stop ${services[*]}"
    fi

    success "Services stopped"
}

# ============================================================================
# Command: restart
# ============================================================================
cmd_restart() {
    local services=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker restart [services...] [options]

Restart Jacker services.

${YELLOW}Options:${NC}
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker restart              # Restart all services
  jacker restart traefik      # Restart specific service
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                services+=("$1")
                shift
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    if [[ ${#services[@]} -eq 0 ]]; then
        info "Restarting all services..."
        execute_or_dry_run "docker compose restart"
    else
        # Validate each service
        for service in "${services[@]}"; do
            if ! validate_service_name "$service"; then
                return 1
            fi
        done

        info "Restarting services: ${services[*]}"
        execute_or_dry_run "docker compose restart ${services[*]}"
    fi

    success "Services restarted"
}

# ============================================================================
# Command: status
# ============================================================================
cmd_status() {
    local watch_mode=false
    local format="table"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --watch|-w)
                watch_mode=true
                shift
                ;;
            --json)
                format="json"
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker status [options]

Show status of Jacker services.

${YELLOW}Options:${NC}
  --watch, -w     Watch mode (refresh every 2s)
  --json          Output in JSON format
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker status           # Show current status
  jacker status --watch   # Watch status updates
  jacker status --json    # JSON output
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    if [[ "$watch_mode" == "true" ]]; then
        watch -n 2 "docker compose ps --format \"$format\""
    else
        docker compose ps --format "$format"
    fi
}

# ============================================================================
# Command: logs
# ============================================================================
cmd_logs() {
    local service=""
    local follow=false
    local tail="100"
    local since=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow=true
                shift
                ;;
            --tail)
                tail="$2"
                shift 2
                ;;
            --since)
                since="$2"
                shift 2
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker logs <service> [options]

View logs for a specific service.

${YELLOW}Options:${NC}
  -f, --follow    Follow log output
  --tail N        Number of lines to show (default: 100)
  --since TIME    Show logs since timestamp
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker logs traefik             # Show last 100 lines
  jacker logs traefik -f          # Follow logs
  jacker logs oauth --tail 50     # Show last 50 lines
  jacker logs crowdsec --since 1h # Logs from last hour
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$service" ]]; then
                    service="$1"
                else
                    error "Multiple services specified"
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$service" ]]; then
        error "Service name required"
        echo "Usage: jacker logs <service> [options]"
        echo "Run 'jacker logs --help' for more information"
        return 1
    fi

    cd_jacker_root
    check_env_exists

    # Validate service exists
    if ! validate_service_name "$service"; then
        return 1
    fi

    local args=()
    [[ "$follow" == "true" ]] && args+=("-f")
    [[ -n "$tail" ]] && args+=("--tail" "$tail")
    [[ -n "$since" ]] && args+=("--since" "$since")

    docker compose logs "${args[@]}" "$service"
}

# ============================================================================
# Command: shell
# ============================================================================
cmd_shell() {
    local service=""
    local shell_cmd="/bin/sh"
    local user=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bash)
                shell_cmd="/bin/bash"
                shift
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker shell <service> [options]

Access shell in a service container.

${YELLOW}Options:${NC}
  --bash          Use bash instead of sh
  --user USER     Run shell as specific user
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker shell traefik            # Access traefik container
  jacker shell postgres --bash    # Use bash shell
  jacker shell crowdsec --user root # Run as root
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$service" ]]; then
                    service="$1"
                else
                    error "Multiple services specified"
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$service" ]]; then
        error "Service name required"
        echo "Usage: jacker shell <service> [options]"
        return 1
    fi

    cd_jacker_root
    check_env_exists

    # Validate service exists
    if ! validate_service_name "$service"; then
        return 1
    fi

    local args=()
    [[ -n "$user" ]] && args+=("--user" "$user")

    info "Connecting to \"$service\" container..."
    docker compose exec "${args[@]}" "$service" "$shell_cmd"
}

# ============================================================================
# Command: health
# ============================================================================
cmd_health() {
    local verbose=false
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                verbose=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker health [options]

Run comprehensive health checks on all services.

${YELLOW}Options:${NC}
  --verbose, -v   Show detailed health information
  --json          Output results in JSON format
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker health              # Basic health check
  jacker health --verbose    # Detailed health check
  jacker health --json       # JSON output
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # shellcheck source=assets/lib/monitoring.sh
    source "$JACKER_ROOT/assets/lib/monitoring.sh"
    run_health_check "$verbose" "$json_output"
}

# ============================================================================
# Command: fix
# ============================================================================
cmd_fix() {
    local component=""
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker fix [component] [options]

Fix common issues with Jacker components.

${YELLOW}Components:${NC}
  all             Fix all known issues
  loki            Fix Loki permissions
  traefik         Fix Traefik certificates
  crowdsec        Fix CrowdSec database
  postgres        Fix PostgreSQL issues
  permissions     Fix all file permissions
  network         Fix Docker networks

${YELLOW}Options:${NC}
  --force, -f     Force fix without confirmation
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker fix                  # Interactive fix menu
  jacker fix all              # Fix all issues
  jacker fix loki --force     # Fix Loki without confirmation
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                component="$1"
                shift
                ;;
        esac
    done

    # shellcheck source=assets/lib/fixes.sh
    source "$JACKER_ROOT/assets/lib/fixes.sh"

    if [[ -z "$component" ]]; then
        # Interactive menu
        select_fix_component
    else
        run_fix "$component" "$force"
    fi
}

# ============================================================================
# Command: backup
# ============================================================================
cmd_backup() {
    local location=""
    local include_volumes=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --location|-l)
                location="$2"
                shift 2
                ;;
            --with-volumes)
                include_volumes=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker backup [options]

Create backup of Jacker configuration and data.

${YELLOW}Options:${NC}
  --location, -l PATH   Backup location (default: ./backups)
  --with-volumes        Include Docker volumes in backup
  --help, -h            Show this help message

${GREEN}Examples:${NC}
  jacker backup                           # Default backup
  jacker backup --location /mnt/backup    # Custom location
  jacker backup --with-volumes            # Include volumes
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # shellcheck source=assets/lib/maintenance.sh
    source "$JACKER_ROOT/assets/lib/maintenance.sh"
    create_backup "$location" "$include_volumes"
}

# ============================================================================
# Command: restore
# ============================================================================
cmd_restore() {
    local backup_file=""
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker restore <backup-file> [options]

Restore Jacker from backup.

${YELLOW}Options:${NC}
  --force, -f     Force restore without confirmation
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker restore backup-20240101.tar.gz
  jacker restore /path/to/backup.tar.gz --force
EOF
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                return 1
                ;;
            *)
                backup_file="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$backup_file" ]]; then
        error "Backup file required"
        echo "Usage: jacker restore <backup-file>"
        return 1
    fi

    # shellcheck source=assets/lib/maintenance.sh
    source "$JACKER_ROOT/assets/lib/maintenance.sh"
    restore_backup "$backup_file" "$force"
}

# ============================================================================
# Command: update
# ============================================================================
cmd_update() {
    local check_only=false
    local skip_pull=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check-only|-c)
                check_only=true
                shift
                ;;
            --skip-pull)
                skip_pull=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker update [options]

Update Jacker and service images.

${YELLOW}Options:${NC}
  --check-only, -c   Only check for updates
  --skip-pull        Skip pulling new images
  --help, -h         Show this help message

${GREEN}Examples:${NC}
  jacker update              # Update everything
  jacker update --check-only # Check for updates only
  jacker update --skip-pull  # Update Jacker only
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    # shellcheck source=assets/lib/maintenance.sh
    source "$JACKER_ROOT/assets/lib/maintenance.sh"
    update_jacker "$check_only" "$skip_pull"
}

# ============================================================================
# Command: config
# ============================================================================
cmd_config() {
    local subcommand="${1:-show}"
    shift || true

    case "$subcommand" in
        show)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            show_config "$@"
            ;;
        set)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            set_config "$@"
            ;;
        validate)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            validate_config "$@"
            ;;
        oauth)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            configure_oauth "$@"
            ;;
        domain)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            configure_domain "$@"
            ;;
        ssl)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            configure_ssl "$@"
            ;;
        authentik)
            # shellcheck source=assets/lib/config.sh
            source "$JACKER_ROOT/assets/lib/config.sh"
            configure_authentik "$@"
            ;;
        tracing)
            # shellcheck source=assets/lib/tracing.sh
            source "$JACKER_ROOT/assets/lib/tracing.sh"
            configure_tracing "$@"
            ;;
        help|--help|-h)
            cat << EOF
${GREEN}Usage:${NC} jacker config <subcommand> [options]

Manage Jacker configuration.

${YELLOW}Subcommands:${NC}
  show            Display current configuration
  set             Set configuration value
  validate        Validate configuration
  oauth           Configure OAuth authentication
  domain          Configure domain name
  ssl             Configure SSL certificates
  authentik       Configure Authentik (optional)
  tracing         Configure distributed tracing (Jaeger/OpenTelemetry)

${GREEN}Examples:${NC}
  jacker config show                    # Show all configuration
  jacker config set TZ America/New_York # Set timezone
  jacker config validate                # Validate config
  jacker config oauth --disable         # Disable OAuth
  jacker config domain myserver.com     # Update domain
  jacker config tracing                 # Configure tracing (interactive)
  jacker config tracing jaeger          # Enable Jaeger tracing
  jacker config tracing status          # Show tracing status
EOF
            ;;
        *)
            error "Unknown subcommand: $subcommand"
            cmd_config help
            return 1
            ;;
    esac
}

# ============================================================================
# Command: secrets
# ============================================================================
cmd_secrets() {
    local subcommand="${1:-list}"
    shift || true

    case "$subcommand" in
        list)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            list_secrets "$@"
            ;;
        rotate)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            rotate_secrets "$@"
            ;;
        generate)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            generate_secrets "$@"
            ;;
        verify)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            verify_secrets "$@"
            ;;
        help|--help|-h)
            cat << EOF
${GREEN}Usage:${NC} jacker secrets <subcommand> [options]

Manage Docker secrets.

${YELLOW}Subcommands:${NC}
  list            List all secrets
  rotate          Rotate secrets
  generate        Generate missing secrets
  verify          Verify secrets integrity

${GREEN}Examples:${NC}
  jacker secrets list              # List all secrets
  jacker secrets rotate all        # Rotate all secrets
  jacker secrets rotate postgres   # Rotate specific secret
  jacker secrets generate          # Generate missing secrets
  jacker secrets verify            # Verify all secrets
EOF
            ;;
        *)
            error "Unknown subcommand: $subcommand"
            cmd_secrets help
            return 1
            ;;
    esac
}

# ============================================================================
# Command: alerts
# ============================================================================
cmd_alerts() {
    local subcommand="${1:-test}"
    shift || true

    # Load environment
    cd_jacker_root
    if [[ -f "$JACKER_ROOT/.env" ]]; then
        set -a
        source "$JACKER_ROOT/.env"
        set +a
    fi

    case "$subcommand" in
        test)
            # shellcheck source=assets/lib/alerts.sh
            source "$JACKER_ROOT/assets/lib/alerts.sh"
            test_all_alerts "$@"
            ;;
        telegram)
            # shellcheck source=assets/lib/alerts.sh
            source "$JACKER_ROOT/assets/lib/alerts.sh"
            test_telegram_alerts "$@"
            ;;
        email)
            # shellcheck source=assets/lib/alerts.sh
            source "$JACKER_ROOT/assets/lib/alerts.sh"
            test_email_alerts "$@"
            ;;
        slack)
            # shellcheck source=assets/lib/alerts.sh
            source "$JACKER_ROOT/assets/lib/alerts.sh"
            test_slack_alerts "$@"
            ;;
        config)
            # shellcheck source=assets/lib/alerts.sh
            source "$JACKER_ROOT/assets/lib/alerts.sh"
            show_alert_config "$@"
            ;;
        help|--help|-h)
            cat << EOF
${GREEN}Usage:${NC} jacker alerts <subcommand> [options]

Manage and test alert notifications.

${YELLOW}Subcommands:${NC}
  test            Test all configured alert channels
  telegram        Test Telegram alerts only
  email           Test email alerts only
  slack           Test Slack alerts only
  config          Show alert configuration

${GREEN}Examples:${NC}
  jacker alerts test           # Test all channels
  jacker alerts telegram       # Test Telegram only
  jacker alerts email          # Test email only
  jacker alerts config         # Show configuration
EOF
            ;;
        *)
            error "Unknown subcommand: $subcommand"
            cmd_alerts help
            return 1
            ;;
    esac
}

# ============================================================================
# Command: security
# ============================================================================
cmd_security() {
    local subcommand="${1:-status}"
    shift || true

    case "$subcommand" in
        status)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            security_status "$@"
            ;;
        crowdsec)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            manage_crowdsec "$@"
            ;;
        firewall)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            manage_firewall "$@"
            ;;
        scan)
            # shellcheck source=assets/lib/security.sh
            source "$JACKER_ROOT/assets/lib/security.sh"
            run_security_scan "$@"
            ;;
        help|--help|-h)
            cat << EOF
${GREEN}Usage:${NC} jacker security <subcommand> [options]

Manage security features.

${YELLOW}Subcommands:${NC}
  status          Show security status
  crowdsec        Manage CrowdSec IPS
  firewall        Manage firewall rules
  scan            Run security scan

${GREEN}Examples:${NC}
  jacker security status              # Security overview
  jacker security crowdsec status     # CrowdSec status
  jacker security firewall update     # Update firewall
  jacker security scan                # Run security scan
EOF
            ;;
        *)
            error "Unknown subcommand: $subcommand"
            cmd_security help
            return 1
            ;;
    esac
}

# ============================================================================
# Command: whitelist
# ============================================================================
cmd_whitelist() {
    local subcommand="${1:-list}"
    shift || true

    case "$subcommand" in
        add)
            # Source required libraries
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            # Handle add command
            if [[ $# -eq 0 ]]; then
                # Interactive wizard
                # shellcheck source=assets/lib/whitelist.sh
                source "$JACKER_ROOT/assets/lib/whitelist.sh"
                configure_admin_whitelist "$JACKER_ROOT" "false"
            else
                # Add specific entry
                local entry="$1"
                local reason="${2:-Manual entry via CLI}"

                if crowdsec_whitelist_ip "$entry" "$reason" "$JACKER_ROOT"; then
                    success "Added to whitelist: $entry"
                    info "Restart CrowdSec to apply changes: jacker whitelist reload"
                else
                    error "Failed to add entry to whitelist"
                    return 1
                fi
            fi
            ;;

        remove|rm)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            if [[ $# -eq 0 ]]; then
                error "Entry required"
                echo "Usage: jacker whitelist remove <ip|cidr>"
                return 1
            fi

            local entry="$1"
            if crowdsec_remove_from_whitelist "$entry" "$JACKER_ROOT"; then
                success "Removed from whitelist: $entry"
                info "Restart CrowdSec to apply changes: jacker whitelist reload"
            else
                return 1
            fi
            ;;

        list|show)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            crowdsec_show_whitelist "$JACKER_ROOT"
            ;;

        init)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            init_crowdsec_whitelist "$JACKER_ROOT"
            success "Whitelist initialized"
            ;;

        reload|restart)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            crowdsec_restart "$JACKER_ROOT"
            ;;

        current|test)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"
            # shellcheck source=assets/lib/whitelist.sh
            source "$JACKER_ROOT/assets/lib/whitelist.sh"

            test_current_ip_whitelist
            ;;

        import)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            if [[ $# -eq 0 ]]; then
                error "File path required"
                echo "Usage: jacker whitelist import <file>"
                return 1
            fi

            local file="$1"
            local reason="${2:-Imported via CLI}"

            if crowdsec_import_whitelist "$file" "$reason" "$JACKER_ROOT"; then
                info "Restart CrowdSec to apply changes: jacker whitelist reload"
            else
                return 1
            fi
            ;;

        export)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"

            local output_file="${1:-whitelist-export.txt}"
            crowdsec_export_whitelist "$output_file" "$JACKER_ROOT"
            ;;

        validate)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"
            # shellcheck source=assets/lib/whitelist.sh
            source "$JACKER_ROOT/assets/lib/whitelist.sh"

            validate_whitelist_config "$JACKER_ROOT"
            ;;

        cleanup)
            # shellcheck source=assets/lib/network.sh
            source "$JACKER_ROOT/assets/lib/network.sh"
            # shellcheck source=assets/lib/crowdsec.sh
            source "$JACKER_ROOT/assets/lib/crowdsec.sh"
            # shellcheck source=assets/lib/whitelist.sh
            source "$JACKER_ROOT/assets/lib/whitelist.sh"

            info "Cleaning up whitelist..."
            cleanup_whitelist_duplicates "$JACKER_ROOT"
            cleanup_whitelist_invalid "$JACKER_ROOT"
            info "Restart CrowdSec to apply changes: jacker whitelist reload"
            ;;

        help|--help|-h)
            cat << EOF
${GREEN}Usage:${NC} jacker whitelist <subcommand> [options]

Manage CrowdSec IP/DNS whitelist to prevent blocking admin access.

${YELLOW}Subcommands:${NC}
  add [entry]         Add IP/CIDR/DNS to whitelist (interactive if no entry)
  remove <entry>      Remove entry from whitelist
  list                Show current whitelist
  init                Initialize whitelist file
  reload              Restart CrowdSec to apply changes
  current             Test if current IP is whitelisted
  import <file>       Import entries from file
  export [file]       Export whitelist to file
  validate            Validate whitelist configuration
  cleanup             Remove duplicates and invalid entries

${GREEN}Examples:${NC}
  jacker whitelist add                    # Interactive wizard
  jacker whitelist add 203.0.113.10       # Add specific IP
  jacker whitelist add 198.51.100.0/24    # Add CIDR range
  jacker whitelist remove 203.0.113.10    # Remove IP
  jacker whitelist list                   # Show whitelist
  jacker whitelist current                # Test current IP
  jacker whitelist import ips.txt         # Import from file
  jacker whitelist reload                 # Apply changes

${YELLOW}File Format for Import:${NC}
  One IP, CIDR, or DNS name per line
  Lines starting with # are comments
  Empty lines are ignored

${YELLOW}Common Use Cases:${NC}
  1. Whitelist your current IP:
     jacker whitelist add

  2. Whitelist office network:
     jacker whitelist add 198.51.100.0/24 "Office network"

  3. Whitelist dynamic DNS:
     jacker whitelist add home.dyndns.org

  4. Check if you're whitelisted:
     jacker whitelist current

For more information, see docs/CROWDSEC_WHITELIST.md
EOF
            ;;
        *)
            error "Unknown subcommand: $subcommand"
            cmd_whitelist help
            return 1
            ;;
    esac
}

# ============================================================================
# Command: clean
# ============================================================================
cmd_clean() {
    local force=false
    local deep=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --deep)
                deep=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker clean [options]

Clean up containers, volumes, and data.

${YELLOW}Options:${NC}
  --force, -f     Skip confirmation prompts
  --deep          Deep clean (remove all data)
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker clean              # Interactive cleanup
  jacker clean --force      # Force cleanup
  jacker clean --deep       # Remove everything
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    if [[ "$force" != "true" ]]; then
        warning "This will remove containers and optionally data!"
        if ! confirm_action "Continue with cleanup?"; then
            info "Cleanup cancelled"
            return 0
        fi
    fi

    cd_jacker_root

    info "Stopping all services..."
    docker compose down -v

    if [[ "$deep" == "true" ]]; then
        warning "Deep clean requested - removing all data"
        if [[ "$force" != "true" ]]; then
            if ! confirm_action "Remove ALL data directories?"; then
                info "Skipping data removal"
            else
                info "Removing data directories..."
                sudo rm -rf data/ logs/ backups/
            fi
        else
            info "Removing data directories..."
            sudo rm -rf data/ logs/ backups/
        fi
    fi

    info "Pruning Docker system..."
    docker system prune -af --volumes

    success "Cleanup complete"
}

# ============================================================================
# Command: wipe-data
# ============================================================================
cmd_wipe_data() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker wipe-data [options]

Wipe all service data directories while preserving SSL certificates.

${YELLOW}Description:${NC}
This command permanently deletes all service data including:
  - PostgreSQL databases
  - Redis cache
  - Prometheus metrics
  - Grafana dashboards
  - Loki logs
  - CrowdSec data
  - All other service data

By default, SSL certificates (acme.json) are preserved to avoid
Let's Encrypt rate limits.

${YELLOW}Options:${NC}
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker wipe-data            # Wipe all data (interactive)

${YELLOW}Warning:${NC}
This operation is IRREVERSIBLE. You will be prompted for confirmation.
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    # shellcheck source=assets/lib/maintenance.sh
    source "$JACKER_ROOT/assets/lib/maintenance.sh"
    wipe_data
}

# ============================================================================
# Command: info
# ============================================================================
cmd_info() {
    local format="text"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                format="json"
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker info [options]

Show system and configuration information.

${YELLOW}Options:${NC}
  --json          Output in JSON format
  --help, -h      Show this help message

${GREEN}Examples:${NC}
  jacker info              # Show system info
  jacker info --json       # JSON output
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    section "System Information"

    # System info
    subsection "Host System"
    echo "OS: $(grep PRETTY_NAME /etc/os-release | cut -d'"' -f2)"
    echo "Kernel: $(uname -r)"
    echo "Architecture: $(uname -m)"
    echo "CPU Cores: $(nproc)"
    echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
    echo "Disk Space: $(df -h / | awk 'NR==2 {print $4}' ) available"

    # Docker info
    subsection "Docker Environment"
    echo "Docker Version: $(docker --version | cut -d' ' -f3 | tr -d ',')"
    echo "Compose Version: $(docker compose version --short)"

    # Jacker info
    subsection "Jacker Configuration"
    if [[ -f "$JACKER_ROOT/.env" ]]; then
        echo "Domain: $(grep '^DOMAINNAME=' .env | cut -d'=' -f2)"
        echo "FQDN: $(grep '^PUBLIC_FQDN=' .env | cut -d'=' -f2)"
        echo "OAuth: $(grep '^OAUTH_CLIENT_ID=' .env | cut -d'=' -f2 | grep -q . && echo 'Configured' || echo 'Not configured')"
    else
        echo "Status: Not initialized"
        echo "Run 'jacker init' to set up"
    fi

    # Service status
    subsection "Service Status"
    if [[ -f "$JACKER_ROOT/.env" ]]; then
        local running
        local total
        running=$(docker compose ps --services --filter "status=running" 2>/dev/null | wc -l)
        total=$(docker compose ps --services 2>/dev/null | wc -l)
        echo "Running: \"$running\" / \"$total\" services"
    else
        echo "No services configured"
    fi
}

# ============================================================================
# Command: tune
# ============================================================================
cmd_tune() {
    local force=false

    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                cat << EOF
${GREEN}Usage:${NC} jacker tune [OPTIONS]

Optimize resource allocation based on system capabilities

${YELLOW}Options:${NC}
  -f, --force    Force re-tuning even if already tuned
  -h, --help     Show this help message

${GREEN}Examples:${NC}
  jacker tune              # Analyze and optimize resources
  jacker tune --force      # Force resource re-optimization

${YELLOW}Description:${NC}
This command analyzes your system's CPU and memory capabilities and
automatically generates optimal resource allocations for all services
in docker-compose.override.yml. It considers:
  - Total CPU cores and memory
  - System reserves for host processes
  - Service dependencies and priorities
  - Resource profiles (minimal/balanced/performance)

The generated override file will be used on next service restart.
EOF
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    cd_jacker_root
    check_env_exists

    # Source resources library
    # shellcheck source=assets/lib/resources.sh
    source "$JACKER_ROOT/assets/lib/resources.sh" || {
        error "Failed to source resources.sh"
        exit 1
    }

    info "Analyzing system capabilities..."

    # Apply resource tuning
    if apply_resource_tuning "$JACKER_ROOT/docker-compose.override.yml"; then
        success "Resource tuning applied successfully"

        # Prompt for restart
        echo ""
        read -rp "Restart services to apply changes? [Y/n]: " restart_services
        restart_services=${restart_services:-Y}

        if [[ "$restart_services" =~ ^[Yy] ]]; then
            info "Restarting services..."
            docker compose restart
            success "Services restarted with new resource allocations"
        else
            info "Resource allocations will be applied on next restart"
            info "Run: ./jacker restart"
        fi
    else
        error "Resource tuning failed"
        exit 1
    fi
}

# ============================================================================
# Command: version
# ============================================================================
cmd_version() {
    echo "Jacker v${VERSION}"
    echo "Copyright (c) 2024 Jacker Project"
    echo "License: MIT"
    echo ""
    echo "GitHub: https://github.com/yourusername/jacker"
    echo "Docs: https://jacker.io"
}

# ============================================================================
# Main Entry Point
# ============================================================================
main() {
    # Initialize global flags
    export VERBOSE=false
    export QUIET=false
    export DRY_RUN=false

    # Parse global flags first
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i|--interactive)
                # Source TUI library and launch interactive mode
                # shellcheck source=assets/lib/tui.sh
                source "$JACKER_ROOT/assets/lib/tui.sh"
                run_interactive_mode
                exit $?
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --version)
                cmd_version
                exit 0
                ;;
            --help)
                show_usage
                exit 0
                ;;
            --)
                shift
                args+=("$@")
                break
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # Restore positional parameters
    set -- "${args[@]}"

    # Handle version and help as commands (legacy support)
    case "${1:-}" in
        version)
            cmd_version
            exit 0
            ;;
        help)
            show_usage
            exit 0
            ;;
        *)
            # Continue with normal command processing
            ;;
    esac

    # Load user configuration if exists
    load_user_config

    # Check if running from Jacker directory
    if [[ ! -f "$JACKER_ROOT/docker-compose.yml" ]]; then
        error "Not in Jacker directory"
        error "Please run from the Jacker installation directory"
        exit 1
    fi

    # Route to command
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        # Core commands
        init|setup)
            cmd_init "$@"
            ;;
        start|up)
            cmd_start "$@"
            ;;
        stop|down)
            cmd_stop "$@"
            ;;
        restart)
            cmd_restart "$@"
            ;;
        status|ps)
            cmd_status "$@"
            ;;
        logs|log)
            cmd_logs "$@"
            ;;
        shell|exec|sh)
            cmd_shell "$@"
            ;;

        # Management commands
        health|check)
            cmd_health "$@"
            ;;
        fix|repair)
            cmd_fix "$@"
            ;;
        backup|bak)
            cmd_backup "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        update|upgrade)
            cmd_update "$@"
            ;;
        clean|cleanup)
            cmd_clean "$@"
            ;;
        wipe-data)
            cmd_wipe_data "$@"
            ;;

        # Configuration commands
        config|configure|cfg)
            cmd_config "$@"
            ;;
        secrets|secret)
            cmd_secrets "$@"
            ;;
        security|sec)
            cmd_security "$@"
            ;;
        whitelist)
            cmd_whitelist "$@"
            ;;

        # Alert commands
        alerts|alert)
            cmd_alerts "$@"
            ;;

        # Information commands
        info|information)
            cmd_info "$@"
            ;;

        # Performance tuning
        tune|optimize)
            cmd_tune "$@"
            ;;

        # Unknown command
        *)
            error "Unknown command: $cmd"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
