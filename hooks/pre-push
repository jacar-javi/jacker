#!/usr/bin/env bash
#
# Pre-push hook for Jacker project
# Runs comprehensive tests before pushing to remote
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Get the root directory of the repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Function to print colored messages
print_header() {
    echo -e "\n${BLUE}==>${NC} $1"
}

print_subheader() {
    echo -e "${CYAN}  ➜${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

# Track if any test fails
FAILED=0

echo -e "${BLUE}╔════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║        JACKER PRE-PUSH VALIDATION         ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════╝${NC}"

# ============================================================================
# 1. Run ShellCheck on ALL scripts
# ============================================================================
print_header "Running ShellCheck on all scripts"

if command -v shellcheck >/dev/null 2>&1; then
    # Check main jacker script
    print_subheader "Checking main CLI..."
    if shellcheck -S error jacker >/dev/null 2>&1; then
        print_success "jacker CLI passes ShellCheck"
    else
        print_error "jacker CLI has ShellCheck errors:"
        shellcheck -S error jacker 2>&1 | head -20
        FAILED=1
    fi

    # Check library modules
    print_subheader "Checking library modules..."
    LIB_ERRORS=0
    for script in assets/lib/*.sh; do
        if [ -f "$script" ]; then
            if ! shellcheck -S error "$script" >/dev/null 2>&1; then
                print_error "$(basename "$script") has errors"
                shellcheck -S error "$script" 2>&1 | head -10
                LIB_ERRORS=1
            fi
        fi
    done

    if [ $LIB_ERRORS -eq 0 ]; then
        print_success "All library modules pass ShellCheck"
    else
        FAILED=1
    fi

    # Check other scripts
    print_subheader "Checking other scripts..."
    OTHER_SCRIPTS=$(find assets -name "*.sh" -not -path "assets/lib/*" 2>/dev/null || true)
    OTHER_ERRORS=0
    for script in $OTHER_SCRIPTS; do
        if [ -f "$script" ]; then
            if ! shellcheck -S warning "$script" >/dev/null 2>&1; then
                print_warning "$(basename "$script") has warnings"
                OTHER_ERRORS=1
            fi
        fi
    done

    if [ $OTHER_ERRORS -eq 0 ]; then
        print_success "All other scripts pass ShellCheck"
    fi
else
    print_error "ShellCheck not installed!"
    echo "  Install with: apt-get install shellcheck"
    FAILED=1
fi

# ============================================================================
# 2. Validate ALL YAML files
# ============================================================================
print_header "Validating YAML files"

YAML_FILES=$(find . -name "*.yml" -o -name "*.yaml" | grep -v ".git/" | grep -v "node_modules/" || true)
YAML_ERRORS=0

if command -v yamllint >/dev/null 2>&1; then
    for yaml_file in $YAML_FILES; do
        if [ -f "$yaml_file" ]; then
            if ! yamllint -d relaxed "$yaml_file" >/dev/null 2>&1; then
                print_error "Invalid YAML: $yaml_file"
                yamllint -d relaxed "$yaml_file" 2>&1 | head -5
                YAML_ERRORS=1
            fi
        fi
    done

    if [ $YAML_ERRORS -eq 0 ]; then
        print_success "All YAML files are valid"
    else
        FAILED=1
    fi
elif command -v python3 >/dev/null 2>&1; then
    print_subheader "Using Python for YAML validation..."
    for yaml_file in $YAML_FILES; do
        if [ -f "$yaml_file" ]; then
            if ! python3 -c "import yaml; yaml.safe_load(open('$yaml_file'))" 2>/dev/null; then
                print_error "Invalid YAML: $yaml_file"
                YAML_ERRORS=1
            fi
        fi
    done

    if [ $YAML_ERRORS -eq 0 ]; then
        print_success "All YAML files are valid"
    else
        FAILED=1
    fi
else
    print_warning "No YAML validator available"
fi

# ============================================================================
# 3. Docker Compose validation
# ============================================================================
print_header "Validating Docker Compose configuration"

if command -v docker >/dev/null 2>&1; then
    # Create temporary .env if needed
    ENV_CREATED=0
    if [ ! -f .env ]; then
        print_subheader "Creating temporary .env for validation..."
        cp .env.defaults .env 2>/dev/null || cp .env.sample .env 2>/dev/null || true

        # Set required paths
        sed -i "s|^DOCKERDIR=.*|DOCKERDIR=$REPO_ROOT|" .env 2>/dev/null || true
        sed -i "s|^DATADIR=.*|DATADIR=$REPO_ROOT/data|" .env 2>/dev/null || true

        ENV_CREATED=1
    fi

    # Create required directories for validation
    mkdir -p data/traefik/acme secrets 2>/dev/null || true
    touch data/traefik/acme/acme.json 2>/dev/null || true

    print_subheader "Validating main compose file..."
    if docker compose config >/dev/null 2>&1; then
        print_success "Docker Compose configuration is valid"

        # Count services
        SERVICE_COUNT=$(docker compose config --services 2>/dev/null | wc -l)
        print_success "Found $SERVICE_COUNT services configured"
    else
        print_error "Docker Compose validation failed"
        docker compose config 2>&1 | head -20
        FAILED=1
    fi

    # Clean up
    if [ $ENV_CREATED -eq 1 ]; then
        rm -f .env
    fi
else
    print_warning "Docker not available - skipping compose validation"
fi

# ============================================================================
# 4. Check for required files
# ============================================================================
print_header "Checking required files"

REQUIRED_FILES=(
    "jacker"
    "docker-compose.yml"
    ".env.defaults"
    "README.md"
    "LICENSE"
    "CONTRIBUTING.md"
    "SECURITY.md"
)

FILES_MISSING=0
for file in "${REQUIRED_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        print_error "Missing required file: $file"
        FILES_MISSING=1
    fi
done

if [ $FILES_MISSING -eq 0 ]; then
    print_success "All required files present"
else
    FAILED=1
fi

# ============================================================================
# 5. Check README files in subdirectories
# ============================================================================
print_header "Checking documentation"

README_DIRS=(
    "assets"
    "compose"
    "config"
    "data"
    "secrets"
)

README_MISSING=0
for dir in "${README_DIRS[@]}"; do
    if [ -d "$dir" ] && [ ! -f "$dir/README.md" ]; then
        print_warning "Missing README.md in $dir/"
        README_MISSING=1
    fi
done

if [ $README_MISSING -eq 0 ]; then
    print_success "All README files present"
fi

# ============================================================================
# 6. Test jacker CLI commands
# ============================================================================
print_header "Testing jacker CLI"

if [ -f "jacker" ] && [ -x "jacker" ]; then
    print_subheader "Testing help command..."
    if ./jacker help >/dev/null 2>&1; then
        print_success "Help command works"
    else
        print_error "Help command failed"
        FAILED=1
    fi

    print_subheader "Testing version command..."
    if ./jacker version >/dev/null 2>&1; then
        VERSION=$(./jacker version 2>/dev/null | head -n 1)
        print_success "Version command works: $VERSION"
    else
        print_error "Version command failed"
        FAILED=1
    fi
else
    print_error "jacker CLI not found or not executable"
    FAILED=1
fi

# ============================================================================
# 7. Check for template files
# ============================================================================
print_header "Checking configuration templates"

TEMPLATE_COUNT=$(find assets/templates -name "*.template" 2>/dev/null | wc -l || echo "0")
if [ "$TEMPLATE_COUNT" -gt 0 ]; then
    print_success "Found $TEMPLATE_COUNT template files"

    # Check for key templates
    KEY_TEMPLATES=(
        "assets/templates/loki-config.yml.template"
        "assets/templates/promtail-config.yml.template"
    )

    for template in "${KEY_TEMPLATES[@]}"; do
        if [ ! -f "$template" ]; then
            print_warning "Missing template: $template"
        fi
    done
else
    print_warning "No template files found"
fi

# ============================================================================
# 8. Security scan for secrets
# ============================================================================
print_header "Scanning for hardcoded secrets"

# More comprehensive secret detection
SECRET_PATTERNS=(
    "password.*[:=].*['\"].*['\"]"
    "secret.*[:=].*['\"].*['\"]"
    "api[_-]?key.*[:=].*['\"].*['\"]"
    "token.*[:=].*['\"].*['\"]"
    "private[_-]?key"
    "BEGIN RSA PRIVATE KEY"
    "BEGIN OPENSSH PRIVATE KEY"
    "aws[_-]?access[_-]?key"
    "aws[_-]?secret"
)

SECRETS_FOUND=0
print_subheader "Scanning repository files..."

for pattern in "${SECRET_PATTERNS[@]}"; do
    MATCHES=$(git grep -i "$pattern" 2>/dev/null | grep -vE '(.env.defaults|.env.sample|.env.test|README|test|example|dummy|placeholder|\$\{.*\})' || true)
    if [ -n "$MATCHES" ]; then
        print_warning "Potential secrets found for pattern: $pattern"
        echo "$MATCHES" | head -3
        SECRETS_FOUND=1
    fi
done

if [ $SECRETS_FOUND -eq 0 ]; then
    print_success "No hardcoded secrets detected"
else
    print_warning "Review potential secrets before pushing"
fi

# ============================================================================
# 9. Check branch protection
# ============================================================================
print_header "Checking branch protection"

CURRENT_BRANCH=$(git branch --show-current)
PROTECTED_BRANCHES=("main" "master" "production")

if [[ " ${PROTECTED_BRANCHES[@]} " =~ " ${CURRENT_BRANCH} " ]]; then
    print_warning "Pushing to protected branch: $CURRENT_BRANCH"
    echo "  Ensure you have reviewed all changes carefully"
fi

# ============================================================================
# 10. Check commit messages
# ============================================================================
print_header "Checking recent commit messages"

# Get commits that will be pushed
REMOTE=$(git remote | head -n 1)
if [ -n "$REMOTE" ]; then
    COMMITS_TO_PUSH=$(git log --oneline "$REMOTE/$CURRENT_BRANCH..HEAD" 2>/dev/null | head -5 || true)

    if [ -n "$COMMITS_TO_PUSH" ]; then
        print_subheader "Commits to be pushed:"
        echo "$COMMITS_TO_PUSH" | sed 's/^/    /'

        # Check for conventional commit format
        UNCONVENTIONAL=$(echo "$COMMITS_TO_PUSH" | grep -vE '^[a-f0-9]+ (feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?:' || true)
        if [ -n "$UNCONVENTIONAL" ]; then
            print_warning "Some commits don't follow conventional format"
        else
            print_success "All commits follow conventional format"
        fi
    fi
fi

# ============================================================================
# Final Summary
# ============================================================================
echo ""
echo -e "${BLUE}════════════════════════════════════════════${NC}"

if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}     ✅ ALL PRE-PUSH CHECKS PASSED!${NC}"
    echo -e "${BLUE}════════════════════════════════════════════${NC}"
    echo ""
    echo "Push proceeding..."
    exit 0
else
    echo -e "${RED}     ❌ PRE-PUSH CHECKS FAILED!${NC}"
    echo -e "${BLUE}════════════════════════════════════════════${NC}"
    echo ""
    echo "Please fix the issues above before pushing."
    echo ""
    echo "To bypass these checks (not recommended):"
    echo "  git push --no-verify"
    exit 1
fi