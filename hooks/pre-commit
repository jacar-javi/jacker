#!/usr/bin/env bash
#
# Pre-commit hook for Jacker project
# Runs quick validation tests before allowing commit
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the root directory of the repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Function to print colored messages
print_header() {
    echo -e "\n${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

# Track if any test fails
FAILED=0

# ============================================================================
# 1. Check for staged files
# ============================================================================
print_header "Checking for staged files..."

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)
if [ -z "$STAGED_FILES" ]; then
    print_warning "No files staged for commit"
    exit 0
fi

print_success "Found staged files for validation"

# ============================================================================
# 2. ShellCheck validation for shell scripts
# ============================================================================
print_header "Running ShellCheck on shell scripts..."

# Get staged shell scripts
STAGED_SHELL_SCRIPTS=$(echo "$STAGED_FILES" | grep -E '\.(sh|bash)$' || true)
STAGED_SHELL_SCRIPTS="$STAGED_SHELL_SCRIPTS $(echo "$STAGED_FILES" | grep -E '^jacker$' || true)"

if [ -n "$STAGED_SHELL_SCRIPTS" ] && [ "$STAGED_SHELL_SCRIPTS" != " " ]; then
    if command -v shellcheck >/dev/null 2>&1; then
        for script in $STAGED_SHELL_SCRIPTS; do
            if [ -f "$script" ]; then
                echo -n "  Checking $script... "
                if shellcheck -S error "$script" >/dev/null 2>&1; then
                    echo -e "${GREEN}OK${NC}"
                else
                    echo -e "${RED}FAILED${NC}"
                    shellcheck -S error "$script" || true
                    FAILED=1
                fi
            fi
        done

        if [ $FAILED -eq 0 ]; then
            print_success "All shell scripts pass ShellCheck"
        fi
    else
        print_warning "ShellCheck not installed - skipping shell script validation"
        print_warning "Install with: apt-get install shellcheck (or brew install shellcheck on macOS)"
    fi
else
    print_success "No shell scripts to check"
fi

# ============================================================================
# 3. YAML validation
# ============================================================================
print_header "Validating YAML files..."

# Get staged YAML files
STAGED_YAML_FILES=$(echo "$STAGED_FILES" | grep -E '\.(yml|yaml)$' || true)

if [ -n "$STAGED_YAML_FILES" ]; then
    if command -v yamllint >/dev/null 2>&1; then
        for yaml_file in $STAGED_YAML_FILES; do
            if [ -f "$yaml_file" ]; then
                echo -n "  Checking $yaml_file... "
                if yamllint -d relaxed "$yaml_file" >/dev/null 2>&1; then
                    echo -e "${GREEN}OK${NC}"
                else
                    echo -e "${RED}FAILED${NC}"
                    yamllint -d relaxed "$yaml_file" || true
                    FAILED=1
                fi
            fi
        done

        if [ $FAILED -eq 0 ]; then
            print_success "All YAML files are valid"
        fi
    else
        # Fallback to Python yaml module for basic validation
        if command -v python3 >/dev/null 2>&1; then
            for yaml_file in $STAGED_YAML_FILES; do
                if [ -f "$yaml_file" ]; then
                    echo -n "  Checking $yaml_file... "
                    if python3 -c "import yaml; yaml.safe_load(open('$yaml_file'))" 2>/dev/null; then
                        echo -e "${GREEN}OK${NC}"
                    else
                        echo -e "${RED}FAILED${NC}"
                        python3 -c "import yaml; yaml.safe_load(open('$yaml_file'))" 2>&1 || true
                        FAILED=1
                    fi
                fi
            done
        else
            print_warning "yamllint not installed - skipping YAML validation"
            print_warning "Install with: pip install yamllint"
        fi
    fi
else
    print_success "No YAML files to check"
fi

# ============================================================================
# 4. Check Docker Compose files if modified
# ============================================================================
print_header "Checking Docker Compose configuration..."

COMPOSE_FILES_CHANGED=$(echo "$STAGED_FILES" | grep -E '(docker-compose\.yml|compose/.*\.yml)' || true)

if [ -n "$COMPOSE_FILES_CHANGED" ]; then
    if command -v docker >/dev/null 2>&1; then
        # Create temporary .env if it doesn't exist
        ENV_CREATED=0
        if [ ! -f .env ]; then
            cp .env.defaults .env 2>/dev/null || cp .env.sample .env 2>/dev/null || true
            ENV_CREATED=1
        fi

        echo -n "  Validating Docker Compose configuration... "
        if docker compose config >/dev/null 2>&1; then
            echo -e "${GREEN}OK${NC}"
            print_success "Docker Compose configuration is valid"
        else
            echo -e "${RED}FAILED${NC}"
            docker compose config 2>&1 | head -20 || true
            FAILED=1
        fi

        # Clean up temporary .env if we created it
        if [ $ENV_CREATED -eq 1 ]; then
            rm -f .env
        fi
    else
        print_warning "Docker not available - skipping compose validation"
    fi
else
    print_success "No Docker Compose files changed"
fi

# ============================================================================
# 5. Check for hardcoded secrets
# ============================================================================
print_header "Checking for hardcoded secrets..."

# Simple patterns to detect potential secrets
SECRET_PATTERNS=(
    "password.*=.*['\"].*['\"]"
    "secret.*=.*['\"].*['\"]"
    "api[_-]key.*=.*['\"].*['\"]"
    "token.*=.*['\"].*['\"]"
    "private[_-]key"
)

SECRETS_FOUND=0
for pattern in "${SECRET_PATTERNS[@]}"; do
    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            # Skip .env files and templates
            if [[ "$file" =~ \.(env|template)$ ]] || [[ "$file" =~ ^secrets/ ]]; then
                continue
            fi

            if grep -iE "$pattern" "$file" >/dev/null 2>&1; then
                if ! grep -iE "$pattern" "$file" | grep -qE '(\$\{.*\}|\$[A-Z_]+|""|example|dummy|test|placeholder)'; then
                    print_warning "Potential secret in $file"
                    grep -inE "$pattern" "$file" | head -3 || true
                    SECRETS_FOUND=1
                fi
            fi
        fi
    done
done

if [ $SECRETS_FOUND -eq 1 ]; then
    print_warning "Potential secrets detected - please review"
    echo "  Consider using environment variables or Docker secrets instead"
else
    print_success "No hardcoded secrets detected"
fi

# ============================================================================
# 6. Check file permissions for executables
# ============================================================================
print_header "Checking file permissions..."

# Check if jacker script is executable if modified
if echo "$STAGED_FILES" | grep -q "^jacker$"; then
    if [ -x "jacker" ]; then
        print_success "jacker script has correct permissions"
    else
        print_warning "jacker script is not executable"
        echo "  Run: chmod +x jacker"
        FAILED=1
    fi
fi

# ============================================================================
# 7. Check for large files
# ============================================================================
print_header "Checking for large files..."

LARGE_FILES=0
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
        # Warn if file is larger than 1MB
        if [ "$SIZE" -gt 1048576 ]; then
            SIZE_MB=$((SIZE / 1048576))
            print_warning "Large file: $file (${SIZE_MB}MB)"
            LARGE_FILES=1
        fi
    fi
done

if [ $LARGE_FILES -eq 0 ]; then
    print_success "No large files detected"
fi

# ============================================================================
# 8. Run jacker CLI basic test if main script modified
# ============================================================================
if echo "$STAGED_FILES" | grep -qE "(^jacker$|^assets/lib/.*\.sh$)"; then
    print_header "Testing jacker CLI..."

    if [ -f "jacker" ] && [ -x "jacker" ]; then
        echo -n "  Testing help command... "
        if ./jacker help >/dev/null 2>&1; then
            echo -e "${GREEN}OK${NC}"
            print_success "jacker CLI is functional"
        else
            echo -e "${RED}FAILED${NC}"
            ./jacker help 2>&1 | head -10 || true
            FAILED=1
        fi
    fi
fi

# ============================================================================
# 9. Check for trailing whitespace
# ============================================================================
print_header "Checking for trailing whitespace..."

WHITESPACE_FILES=$(git diff --cached --name-only --diff-filter=ACM | xargs grep -l '[[:space:]]$' 2>/dev/null || true)
if [ -n "$WHITESPACE_FILES" ]; then
    print_warning "Files with trailing whitespace:"
    echo "$WHITESPACE_FILES" | sed 's/^/  - /'
    echo ""
    echo "  Fix with: git diff --cached --name-only | xargs sed -i 's/[[:space:]]*$//'"
else
    print_success "No trailing whitespace found"
fi

# ============================================================================
# Final Summary
# ============================================================================
echo ""
if [ $FAILED -eq 0 ]; then
    print_header "Pre-commit checks passed! ✅"
    echo ""
    echo "Commit proceeding..."
    exit 0
else
    print_header "Pre-commit checks failed! ❌"
    echo ""
    echo "Please fix the issues above and try again."
    echo "To bypass these checks (not recommended), use: git commit --no-verify"
    exit 1
fi